L = ['a', 'b', 'c']
print("Идентификатор объекта -",id(L))

L.append('d')
print("Идентификатор объекта после добавления элемента -",id(L))

print("Находим разностъ значения идентичности двух объектоф: ")
a = 5
b = 3+2
print(id(a), id(b))
print("Разностъ :", id(a) - id(b))
"""
Удивительно, не правда ли? Дело в том, что некоторые целые числа и строки кэшируются в памяти, 
позволяя не создавать каждый раз новый объект. Иными словами, Python при компиляции сам создаёт 
объекты некоторых видов и сохраняет их в памяти. И если в коде встречается «создание» такого объекта, 
то он подгружается из этой временной памяти.
"""
print('*' * 25)
list_1 = ['a', 'b', 'c']
list_2 = list_1
list_3 = list(list_1)
print(list_1)
print(list_2)
print(list_3)
print("Проверка идентичности списков:")
print(list_1 == list_2)
print(list_1 == list_3)
print(list_1 is list_2)
print(list_1 is list_3)
"""Здесь мы можем увидеть (list_1 is list_3) False, потому что list_1 и list_3 указывают 
на два разных объекта, даже если их содержимое может быть одинаковым. Таким образом, мы 
можем сказать, что «is» вернет True, если две переменные указывают на один и тот же объект, 
и «==», если объекты, на которые ссылаются переменные, равны."""
