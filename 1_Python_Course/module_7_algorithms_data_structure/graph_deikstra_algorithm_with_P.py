
# Алгоритм Дейкстры можно модифицировать таким образом, что можно определить не только величину пути, но ещё и сами вершины минимального пути.
#
# Для этого определим ещё один словарь P, в котором будем для каждой вершины хранить вершину-предок с минимальным расстоянием.
#
# P = {k : None for k in G.keys()} Задание 7.5.3 Модифицируйте алгоритм Дейкстры таким образом, что в массив P по
# соответствующему ключу будет записываться предок с минимальным расстоянием, если это необходимо.
G = {"Адмиралтейская" :
         {"Садовая" : 4},
     "Садовая" :
         {"Сенная площадь" : 3,
          "Спасская" : 3,
          "Адмиралтейская" : 4,
          "Звенигородская" : 5},
     "Сенная площадь" :
         {"Садовая" : 3,
          "Спасская" : 3},
     "Спасская" :
         {"Садовая" : 3,
          "Сенная площадь" : 3,
          "Достоевская" : 4},
     "Звенигородская" :
         {"Пушкинская" : 3,
          "Садовая" : 5},
     "Пушкинская" :
         {"Звенигородская" : 3,
          "Владимирская" : 4},
     "Владимирская" :
         {"Достоевская" : 3,
          "Пушкинская" : 4},
     "Достоевская" :
         {"Владимирская" : 3,
          "Спасская" : 4}}
# Мой пример подсчитанный в Яндекс.Метро:
# G = {"Адмиралтейская" :
#          {"Садовая": 2},
#      "Садовая" :
#          {"Сенная площадь": 4,
#           "Спасская": 3,
#           "Адмиралтейская": 2,
#           "Звенигородская": 3},
#      "Сенная площадь" :
#          {"Садовая": 4,
#           "Спасская": 4},
#      "Спасская" :
#          {"Садовая": 3,
#           "Сенная площадь": 4,
#           "Достоевская": 4},
#      "Звенигородская" :
#          {"Пушкинская": 3,
#           "Садовая": 3},
#      "Пушкинская" :
#          {"Звенигородская": 3,
#           "Владимирская": 2},
#      "Владимирская" :
#          {"Достоевская": 3,
#           "Пушкинская": 2},
#      "Достоевская" :
#          {"Владимирская": 3,
#           "Спасская": 4}}


D = {k : 100 for k in G.keys()} # расстояния
start_k = 'Адмиралтейская' # стартовая вершина
D[start_k] = 0 # расстояние от нее до самой себя равно нулю
U = {k : False for k in G.keys()} # флаги просмотра вершин
P = {k : None for k in G.keys()} # предки
print("Массив P:", P)
for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys(): # проходимся по всем смежным вершинам
         if D[v] > D[min_k] + G[min_k][v]: # если расстояние от текущей вершины меньше
            D[v] = D[min_k] + G[min_k][v] # то фиксируем его
            P[v] = min_k # и записываем как предок
    U[min_k] = True # просмотренную вершину помечаем
print("Теперь проходом цикла while по вершинам в словаре P можно найти вершины кратчайшего пути, правда, в обратном порядке: ")
pointer = "Владимирская" # куда должны прийти
while pointer is not None: # перемещаемся, пока не придём в стартовую точку
    print(pointer)
    pointer = P[pointer]

print("Словарь с минимальмыми кратчайшими расстонимями:")
print(D)
print("Массив вершин-предков:", P)

