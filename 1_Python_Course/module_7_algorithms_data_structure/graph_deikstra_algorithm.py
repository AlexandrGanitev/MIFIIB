# При работе с графами одна из наиболее частых задач — поиск кратчайшего пути от одной вершины к другой.
# Сейчас мы с вами попытаемся реализовать алгоритм, позволяющий найти его.
#
# Он носит название «алгоритм Дейкстры».
#
# Его суть заключается в том, чтобы последовательно перебирать вершины одну за другой в поисках кратчайшего
# пути до этой вершины. Вершину будем называть предком для другой, если она идет раньше по пути перемещения
# по ребрам в графе. Ближайший предок — это предок, имеющий прямую связь (ребро) с рассматриваемой. Рассмотрим
# этот алгоритм также на примере взвешенного графа станций метро из последней задачи.
#
# Для начала нам потребуется дополнительная структура данных для хранения расстояний. Если вершины пронумерованы
# числами, то можно использовать массив, но т. к. мы имеем проименованные узлы, то удобнее пользоваться словарём.
#
# D = {k : 100 for k in G.keys()}
# Проинициализируем словарь расстояний числами, которые заведомо больше максимального расстояния в графе. Значения
# 100 в данной задаче нам будет более чем достаточно. Одну из вершин мы должны выбрать как стартовую. Поэтому стартовая
# вершина будет предком для всех остальных. Расстояние для неё (от неё же самой) будет равно нулю. Пусть это будет «Адмиралтейская».
#
# D["Адмиралтейская"] = 0
# Также нам потребуется хранить словарь с булевыми значениями, в котором True — если вершина просмотрена, иначе — False.
#
# U = {k : False for k in G.keys()}
# Далее мы должны пройти циклом из n итераций, выбирая вершину с наименьшим D среди непросмотренных. Очевидно, что на
# первой итерации будет выбрана стартовая вершина. Из неё мы должны проверить все вершины, в которые можем перейти, и
# в D записать наименьшее расстояние до них. Пока что мы можем идти только из стартовой вершины, поэтому запишутся
# именно эти расстояния. Стартовая вершина станет помеченной как уже просмотренная. После чего начнется поиск вершины
# с минимальным D из уже просмотренных (куда можно добраться из стартовой). От неё также будут строиться возможные
# ребра и проверяться минимум расстояний. И так далее, пока процесс не завершится. Утверждается, что достаточно числа
# итераций равного количеству вершин. При достижении этого алгоритм завершится корректно.

G = {"Адмиралтейская" :
         {"Садовая": 2},
     "Садовая" :
         {"Сенная площадь": 4,
          "Спасская": 3,
          "Адмиралтейская": 2,
          "Звенигородская": 3},
     "Сенная площадь" :
         {"Садовая": 4,
          "Спасская": 4},
     "Спасская" :
         {"Садовая": 3,
          "Сенная площадь": 4,
          "Достоевская": 4},
     "Звенигородская" :
         {"Пушкинская": 3,
          "Садовая": 3},
     "Пушкинская" :
         {"Звенигородская": 3,
          "Владимирская": 2},
     "Владимирская" :
         {"Достоевская": 3,
          "Пушкинская": 2},
     "Достоевская" :
         {"Владимирская": 3,
          "Спасская": 4}}


D = {k : 100 for k in G.keys()} # расстояния
start_k = 'Адмиралтейская' # стартовая вершина
D[start_k] = 0 # расстояние от неё до самой себя равно нулю
print("Расстояниа по List Comprehension: ", D)
U = {k : False for k in G.keys()} # флаги просмотра вершин
print("Флаги просмотра вершин: U", U, "\n")
print("Ключи U словаря словарей G, ", U.keys())

for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys(): # проходимся по всем смежным вершинам
        D[v] = min(D[v], D[min_k] + G[min_k][v]) # минимум
        print("Минимумы D[v]: ", D[v])
    U[min_k] = True # просмотренную вершину помечаем

print("Словарь с минимальмыми кратчайшими расстонимями:")
print(D)
