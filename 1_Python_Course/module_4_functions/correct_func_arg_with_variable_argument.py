# Видим, что при одних и тех же входных данных функция выдает разные результаты,
# что в дальнейшей разработке может вводить в заблуждение. Если вдруг внутри функции
# нужно использовать списки, то этот момент можно обойти следующим образом:

# установим аргумент name_arg пустым а внутри функции будем проверять его
def correct_func(name_arg=None):
    # Здесь мы вводим проверку на тип аргумента (изменяемый/неизменяемый тип)
    # Если пользователь не предопределит аргумент, то он станет типом None (unmutable - неизменяемый)
    if name_arg is None:
        name_arg = []
    print("Аргумент до изменения", name_arg)
    name_arg.append(1)
    print("Аргумент после изменения", name_arg)


# вызовем два раза одну и ту же функцию
correct_func()
print('-----')
correct_func()
print('-----')
correct_func([123])
print('-----')
correct_func(name_arg=[123])

# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения [123]
# Аргумент после изменения [123, 1]
# -----
# Аргумент до изменения [123]
# Аргумент после изменения [123, 1]

"""
Чтобы избежать этого, создадим функцию correct_func, где в качестве значения по умолчанию 
укажем значение None. А вот уже внутри функции будем проверять, если пользователь не поменял 
это значение, то будем инициализировать, например, пустой список. И тогда всё будет хорошо, 
при каждом вызове функции, если это необходимо, этот пустой список будет инициализироваться 
вместе со всеми остальными аргументами функции.
"""
